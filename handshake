local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer

local cachedGC = nil
local lastGCUpdate = 0
local GC_CACHE_TIME = 3

local function getCachedGC()
    local currentTime = tick()
    if not cachedGC or (currentTime - lastGCUpdate) > GC_CACHE_TIME then
        cachedGC = getgc(true)
        lastGCUpdate = currentTime
    end
    return cachedGC
end

if not is_synapse_function then
    function is_synapse_function(_)
        return false
    end
end

local blockedFunctions = {"cvSCVfv", "jdvs_dvcddv"}
local function blockFunctionsByName(targetNames)
    local gcList = getCachedGC()
    local blockedCount = 0
    
    for _, obj in ipairs(gcList) do
        if type(obj) == "function" and not is_synapse_function(obj) then
            local success, info = pcall(debug.getinfo, obj)
            if success and info.name then
                for _, targetName in ipairs(targetNames) do
                    if info.name == targetName then
                        local success2 = pcall(hookfunction, obj, function()
                            return nil
                        end)
                        if success2 then
                            blockedCount = blockedCount + 1
                            print("Blocked function: " .. targetName)
                        end
                        break
                    end
                end
            end
        end
    end
    
    print("Blocked " .. blockedCount .. " functions")
end

blockFunctionsByName(blockedFunctions)

local services = {
    game:GetService("VoiceChatService"),
    game:GetService("BrowserService"),
    game:GetService("AssetService")
}

local suspiciousPattern = "[^%w_]"

local function findEncodeModule()
    print("ðŸ” Searching for EncodeModule (service-scoped)...")
    
    for _, service in ipairs(services) do
        local descendants = service:GetDescendants()
        for _, obj in ipairs(descendants) do
            if obj:IsA("ModuleScript") then
                -- Changing/obfuscated names are the target; prefer suspicious names
                if obj.Name:match(suspiciousPattern) or #obj.Name > 20 then
                    obj.Name = "EncodeModule"
                    print("âœ… Found EncodeModule in " .. service.Name .. ": " .. obj.Name)
                    return obj
                end
            end
        end
        -- Fallback: first ModuleScript in this service if no suspicious one found
        for _, obj in ipairs(descendants) do
            if obj:IsA("ModuleScript") then
                print("âœ… Using first ModuleScript in " .. service.Name .. ": " .. obj.Name)
                return obj
            end
        end
    end
    
    print("âŒ No EncodeModule found in target services")
    return nil
end

local function cleanupServices()
    local destroyedCount = 0
    local targetService = nil
    
    for _, service in ipairs(services) do
        local hasModuleScript = false
        local descendants = service:GetDescendants()
        
        for _, obj in ipairs(descendants) do
            if obj:IsA("Script") and obj.Name:match(suspiciousPattern) and obj:IsDescendantOf(game) then
                local success = pcall(function()
                    obj:Destroy()
                end)
                if success then
                    destroyedCount = destroyedCount + 1
                end
            elseif obj:IsA("ModuleScript") then
                hasModuleScript = true
            end
        end
        
        if not hasModuleScript and not targetService then
            targetService = service
        end
    end
    
    print("Destroyed " .. destroyedCount .. " suspicious scripts")
    
    local encodeModule = findEncodeModule()
    
    return encodeModule, targetService
end

local encodeModule, targetService = cleanupServices()

local function waitForEncodeModule(timeoutSeconds)
    local startTime = tick()
    local servicesToCheck = {
        game:GetService("VoiceChatService"),
        game:GetService("BrowserService"),
        game:GetService("AssetService")
    }
    repeat
        for _, service in ipairs(servicesToCheck) do
            for _, obj in ipairs(service:GetDescendants()) do
                if obj:IsA("ModuleScript") then
                    return obj, service
                end
            end
        end
        task.wait(0.1)
    until tick() - startTime > timeoutSeconds
    return nil, nil
end

if not encodeModule then
    local foundModule, foundService = waitForEncodeModule(3)
    if foundModule then
        encodeModule = foundModule
        if not targetService then
            targetService = foundService
        end
        print("Fallback found EncodeModule: " .. encodeModule.Name .. " in " .. (targetService and targetService.Name or "unknown"))
    end
end

if targetService then
    local nilInstances = getnilinstances()
    local movedCount = 0
    
    for _, obj in ipairs(nilInstances) do
        if typeof(obj) == "Instance" and obj.ClassName == "ModuleScript" then
            local success = pcall(function()
                obj.Parent = targetService
            end)
            if success then
                movedCount = movedCount + 1
            end
        end
    end
    
    print("Moved " .. movedCount .. " ModuleScripts to " .. targetService.Name)
end

local eventsFolder = ReplicatedStorage:WaitForChild("Events")
local targetRemote = nil

local function isTargetRemote(name)
    if name:match("^\n%d+\nY%..*R.*") then
        local sections = {}
        for section in name:gmatch("\n%d+\nY%.[^%z]*") do
            table.insert(sections, section)
        end
        return #sections >= 2
    end
    return false
end

local events = eventsFolder:GetChildren()
for _, obj in ipairs(events) do
    if obj:IsA("RemoteEvent") then
        if isTargetRemote(obj.Name) then
            targetRemote = obj
            print("Found target remote with pattern match: " .. obj.Name:gsub("\n", "\\n"))
            break
        elseif obj.Name:match(suspiciousPattern) and #obj.Name > 10 then
            targetRemote = obj
            print("Found suspicious remote: " .. obj.Name:gsub("\n", "\\n"))
            break
        end
    end
end

if not targetRemote then
    print("Available RemoteEvents in Events folder:")
    for _, obj in ipairs(events) do
        if obj:IsA("RemoteEvent") then
            local displayName = obj.Name:gsub("\n", "\\n"):gsub("\r", "\\r")
            print("- " .. displayName .. " (Length: " .. #obj.Name .. ")")
        end
    end
end

if encodeModule and targetRemote then
    local success, Encode = pcall(require, encodeModule)
    
    if success and Encode then
        print("Starting handshake emulation...")
        print("Target Remote: " .. targetRemote.Name:gsub("\n", "\\n"))
        print("Encode Module: " .. encodeModule.Name)
        print("Module Type: " .. type(Encode))
        
        local encodeFunction = nil
        
        if type(Encode) == "table" and type(Encode.encode) == "function" then
            print("âœ… Found table with encode function")
            encodeFunction = Encode.encode
        elseif type(Encode) == "function" then
            print("âœ… Module itself is the encode function")
            encodeFunction = Encode
        else
            warn("âŒ Invalid module format - not a table with encode or encode function")
            if type(Encode) == "table" then
                print("Available functions in module:")
                for k, v in pairs(Encode) do
                    print("- " .. tostring(k) .. ": " .. type(v))
                end
            end
            encodeFunction = nil
        end
        
        if encodeFunction then
            local CONSTANTS = {
                PREFIX = "ksssss",
                MULTIPLIER = 69,
                DIVISOR_1 = 2.8232,
                DIVISOR_2 = 43673023,
                SEPARATOR = "-"
            }
            
            local function emulateHandshake()
                local serverTime = workspace:GetServerTimeNow()
                local sinTime = math.sin(serverTime)
                local part1Data = CONSTANTS.PREFIX .. CONSTANTS.SEPARATOR .. tostring(sinTime * CONSTANTS.MULTIPLIER / CONSTANTS.DIVISOR_1)
                local part2Data = tostring(sinTime / CONSTANTS.DIVISOR_2)
                
                print("ðŸ”§ Debug: Testing encode function...")
                print("Part1 data: " .. part1Data)
                print("Part2 data: " .. part2Data)
                print("Encode function type: " .. type(encodeFunction))
                
                local testSuccess, testResult = pcall(encodeFunction, "test")
                if testSuccess then
                    print("âœ… Encode function works with test data: " .. type(testResult))
                else
                    warn("âŒ Encode function failed with test data: " .. tostring(testResult))
                end
                
                local part1, part2 = nil, nil
                
                local part1Success, part1Result = pcall(encodeFunction, part1Data)
                if part1Success then
                    part1 = part1Result
                    print("âœ… Part1 encoded successfully (direct)")
                else
                    warn("âŒ Part1 encoding failed (direct): " .. tostring(part1Result))
                    
                    if type(Encode) == "table" then
                        part1Success, part1Result = pcall(Encode.encode, Encode, part1Data)
                        if part1Success then
                            part1 = part1Result
                            print("âœ… Part1 encoded successfully (self call)")
                        else
                            warn("âŒ Part1 encoding failed (self call): " .. tostring(part1Result))
                        end
                    end
                end
                
                local part2Success, part2Result = pcall(encodeFunction, part2Data)
                if part2Success then
                    part2 = part2Result
                    print("âœ… Part2 encoded successfully (direct)")
                else
                    warn("âŒ Part2 encoding failed (direct): " .. tostring(part2Result))
                    
                    if type(Encode) == "table" then
                        part2Success, part2Result = pcall(Encode.encode, Encode, part2Data)
                        if part2Success then
                            part2 = part2Result
                            print("âœ… Part2 encoded successfully (self call)")
                        else
                            warn("âŒ Part2 encoding failed (self call): " .. tostring(part2Result))
                        end
                    end
                end
                
                if part1 and part2 then
                    print("ðŸ” Encoded data types: Part1=" .. type(part1) .. ", Part2=" .. type(part2))
                    
                    local handshakeSuccess = pcall(function()
                        targetRemote:FireServer(part1, part2)
                    end)
                    
                    if handshakeSuccess then
                        print("âœ… Handshake sent successfully")
                    else
                        warn("âŒ Failed to send handshake to remote")
                    end
                else
                    warn("âŒ Could not encode handshake data with any method")
                end
            end

            local elapsed = 0
            RunService.Heartbeat:Connect(function(dt)
                elapsed = elapsed + dt
                if elapsed >= 10 then
                    elapsed = 0
                    emulateHandshake()
                end
            end)
            
            task.spawn(function()
                task.wait(2)
                emulateHandshake()
            end)
            
            print("Handshake emulation started successfully")
            print("Constants: PREFIX=" .. CONSTANTS.PREFIX .. ", MULT=" .. CONSTANTS.MULTIPLIER .. ", DIV1=" .. CONSTANTS.DIVISOR_1 .. ", DIV2=" .. CONSTANTS.DIVISOR_2)
        end
    else
        warn("Failed to load EncodeModule")
        print("Require error for module: " .. encodeModule.Name)
    end
else
    warn("EncodeModule or target RemoteEvent not found")
    if not encodeModule then
        warn("EncodeModule is nil")
    end
    if not targetRemote then
        warn("targetRemote is nil")
    end
end

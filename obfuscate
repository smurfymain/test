-- Wrap closure kullanarak geliştirilmiş hooking sistemi
local function createHookWrapper(originalFunc, hookBehavior)
    return function(...)
        local args = {...}
        
        -- Hook davranışını kontrol et
        if hookBehavior == "block" then
            return nil
        elseif hookBehavior == "log" then
            print("Function called with args:", table.concat(args, ", "))
            return originalFunc(...)
        elseif hookBehavior == "modify" then
            -- Argümanları modifiye et
            return originalFunc(...)
        end
        
        return originalFunc(...)
    end
end

-- Geliştirilmiş hooking sistemi
local function advancedHooking()
    local hookedFunctions = {}
    
    return {
        hookByConstant = function(targetConstant, behavior)
            for _, func in next, getgc(true) do
                if typeof(func) == "function" and not is_synapse_function(func) then
                    local success, constants = pcall(debug.getconstants, func)
                    if success and constants then
                        for _, constant in pairs(constants) do
                            if constant == targetConstant then
                                local wrapper = createHookWrapper(func, behavior)
                                local hookSuccess = pcall(hookfunction, func, wrapper)
                                if hookSuccess then
                                    table.insert(hookedFunctions, {
                                        original = func,
                                        wrapper = wrapper,
                                        constant = targetConstant
                                    })
                                end
                                break
                            end
                        end
                    end
                end
            end
        end,
        
        getHookedCount = function()
            return #hookedFunctions
        end,
        
        unhookAll = function()
            for _, hookData in pairs(hookedFunctions) do
                pcall(hookfunction, hookData.wrapper, hookData.original)
            end
            hookedFunctions = {}
        end
    }
end

-- Handshake emulation için wrap closure
local function createHandshakeEmulator(encodeFunction, targetRemote, constants)
    local lastHandshakeTime = 0
    local handshakeCount = 0
    
    return function()
        local currentTime = tick()
        
        -- Rate limiting
        if currentTime - lastHandshakeTime < 2 then
            return false
        end
        
        lastHandshakeTime = currentTime
        handshakeCount = handshakeCount + 1
        
        local serverTime = workspace:GetServerTimeNow()
        local sinTime = math.sin(serverTime)
        
        -- Wrap closure ile data generation
        local dataGenerator = function(prefix, multiplier, divisor)
            return function(timeValue)
                return prefix .. constants.SEPARATOR .. tostring(timeValue * multiplier / divisor)
            end
        end
        
        local part1Generator = dataGenerator(constants.PREFIX, constants.MULTIPLIER, constants.DIVISOR_1)
        local part2Generator = dataGenerator("", 1, constants.DIVISOR_2)
        
        local part1Data = part1Generator(sinTime)
        local part2Data = part2Generator(sinTime)
        
        -- Encoding with error handling
        local function safeEncode(data)
            local success, result = pcall(encodeFunction, data)
            if not success and type(encodeFunction) == "table" then
                success, result = pcall(encodeFunction.encode, encodeFunction, data)
            end
            return success and result or nil
        end
        
        local part1 = safeEncode(part1Data)
        local part2 = safeEncode(part2Data)
        
        if part1 and part2 then
            local success = pcall(function()
                targetRemote:FireServer(part1, part2)
            end)
            
            if success then
                print(string.format("Handshake #%d sent successfully", handshakeCount))
                return true
            end
        end
        
        return false
    end
end

-- Dynamic module finder with wrap closure
local function createModuleFinder()
    local cache = {}
    local searchPatterns = {
        encode = {"encode", "crypt", "hash", "cipher"},
        suspicious = "[^%w_]"
    }
    
    return {
        findByPattern = function(pattern)
            if cache[pattern] then
                return cache[pattern]
            end
            
            local found = nil
            
            -- Wrap closure ile search function
            local searchFunction = function(container, validator)
                for _, obj in ipairs(container:GetDescendants()) do
                    if obj:IsA("ModuleScript") and validator(obj) then
                        return obj
                    end
                end
                return nil
            end
            
            -- Validator wrap closures
            local validators = {
                suspicious = function(obj)
                    return obj.Name:match(searchPatterns.suspicious) and #obj.Name > 5
                end,
                
                encode = function(obj)
                    local name = obj.Name:lower()
                    for _, keyword in pairs(searchPatterns.encode) do
                        if name:find(keyword) then
                            return true
                        end
                    end
                    return false
                end
            }
            
            -- Search in services
            local services = {
                game:GetService("VoiceChatService"),
                game:GetService("BrowserService"),
                game:GetService("AssetService")
            }
            
            for _, service in ipairs(services) do
                found = searchFunction(service, validators[pattern] or validators.suspicious)
                if found then break end
            end
            
            -- Search globally if not found
            if not found then
                found = searchFunction(game, validators[pattern] or validators.suspicious)
            end
            
            cache[pattern] = found
            return found
        end,
        
        clearCache = function()
            cache = {}
        end
    }
end

-- Ana bypass sistemi
local function initializeBypass()
    local hooker = advancedHooking()
    local moduleFinder = createModuleFinder()
    
    -- Hook target functions
    hooker.hookByConstant("cvSCVfv", "block")
    
    print(string.format("Hooked %d functions", hooker.getHookedCount()))
    
    -- Find encode module
    local encodeModule = moduleFinder.findByPattern("encode") or moduleFinder.findByPattern("suspicious")
    
    if encodeModule then
        local success, Encode = pcall(require, encodeModule)
        
        if success and Encode then
            -- Find target remote
            local eventsFolder = ReplicatedStorage:WaitForChild("Events")
            local targetRemote = nil
            
            for _, obj in ipairs(eventsFolder:GetChildren()) do
                if obj:IsA("RemoteEvent") and (obj.Name:match("^\n%d+\nY%..*R.*") or (#obj.Name > 10 and obj.Name:match("[^%w_]"))) then
                    targetRemote = obj
                    break
                end
            end
            
            if targetRemote then
                local CONSTANTS = {
                    PREFIX = "ksssss",
                    MULTIPLIER = 69,
                    DIVISOR_1 = 2.8232,
                    DIVISOR_2 = 43673023,
                    SEPARATOR = "-"
                }
                
                local handshakeEmulator = createHandshakeEmulator(Encode, targetRemote, CONSTANTS)
                
                -- Auto handshake system
                local elapsed = 0
                RunService.Heartbeat:Connect(function(dt)
                    elapsed = elapsed + dt
                    if elapsed >= 10 then
                        elapsed = 0
                        handshakeEmulator()
                    end
                end)
                
                -- Initial handshake
                task.spawn(function()
                    task.wait(2)
                    if handshakeEmulator() then
                        print("Bypass loaded successfully!")
                    end
                end)
            end
        end
    end
end

-- Initialize the bypass system
initializeBypass()
